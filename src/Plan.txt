Plan:

- Piece parent class. Each piece has method called computeMoves
- BoardStateManager is for setting up board, checking for location of pieces (when determining validity),
	checking for mate, maybe also checks, value of board
- Negamax class

- At first glance, each piece has unit directions and can either move once in that direction or multiple times.
	The exceptions seem to be castling, pawns (2 move from starting row)

- BM will have to initialize all Piece Move Generators

State
- colorAt(pos) (Black, white, null)
- canCastleRight()
- canCastleLeft()
- getCurrentPlayer() returns Color
- posIsEmpty(Pos)
- isControlled(Pos, Color, Mode, Pins/Not)
- setEnPassant(Pos): Only used for setting en passant for a specific state where used 2-step open. All new states generated from this state will have the enPassant variable initialized to null
- getEnPassant() returns a Pos (could be null)

BM
- genNewState() 
- inBounds()
- oppositeColor(Color)
- Color getUserColor()

Have a Map of positions to chars.
Get Check and Pin positions from State.
If checked, call checkHandler(). Else, compute states for each piece.
In CheckHandler class, if multiple checks, return KingMoveGenerator's computeValidPositions without performing individualComputation(), which does castling.
Otherwise, one check, so in addition to the moves from KingMoveGenerator without individualComputation, we can eat the checking position or block it.

Blocking requires knowing whether *empty* squares between checked king and checking piece are controlled by any same-team pieces. For every square in between, check if it isControlled()

isControlled() will try every piece to see if the movesGenerated will include the piece.
isControlled() needs different modes. The mode will determine the pieces to try and the moves to try.
For blocking, we will skip the king and only try commonComp moves 
For eating, we can try all non-castle moves for king and all attacking individualMoves for pawn, but no pawn commonMoves or 2 move start.

B/c of this design, PawnMoveGenerator's unitDirs will be one forward. Blocking will necessitate trying common move and 2 move start. Capture (including en passant) will be individualComputation.

So if not checked:
for each pos in Map:
	if pos not in pinned:
		Generate moves for the appropriate piece using switch case

White pawn move generator and black pawn move generator