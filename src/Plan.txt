Plan:

- Piece parent class. Each piece has method called computeMoves
- BoardStateManager is for setting up board, checking for location of pieces (when determining validity),
	checking for mate, maybe also checks, value of board
- Negamax class

- At first glance, each piece has unit directions and can either move once in that direction or multiple times.
	The exceptions seem to be castling, pawns (2 move from starting row)

- BM will have to initialize all Piece Move Generators

State
- colorAt(pos)
- canCastleRight()
- canCastleLeft()
- getCurrentPlayer() returns Color

BM
- genNewState() has a param _switch that says whether/not to switch the chars at the 2 positions
- inBounds()
- getInitKingPos(Color)
- getInitRookPos(Color, CastleDir)

Have a Map of positions to chars.
Get Check and Pin positions from State.
If checked, call checkHandler(). Else, compute states for each piece.
In CheckHandler class, if multiple checks, return KingMoveGenerator's computeValidPositions without performing individualComputation(), which does castling.
Otherwise, one check, so in addition to the moves from KingMoveGenerator without individualComputation, we can eat the checking position or block it.

Blocking requires knowing whether *empty* squares between checked king and checking piece are controlled by any same-team pieces. For every square in between, check if it isControlled()

isControlled() will try every piece to see if the movesGenerated will include the piece.
isControlled() needs different modes. The mode will determine the pieces to try and the moves to try.
For blocking, we will skip the king and only try commonComp moves (relevant only to pawn, which can move forward 1 or 2 to block).
For eating, we can try all non-castle moves for king and all individualMoves for pawn, but no pawn commonMoves.

B/c of this design, PawnMoveGenerator's unitDirs will be one forward or 2 forward (so commonComp will try both for things like blocking). Capture (including en passant) will be individualComputation.

So if not checked:
for each pos in Map:
	if pos not in pinned:
		Generate moves for the appropriate piece using switch case
